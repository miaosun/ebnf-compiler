/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Ebnf.jj */
/*@egen*///http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form


PARSER_BEGIN(Ebnf)
// C\u00c3\u00b3digo Java que invoca o parser
import java.util.HashMap;
import java.lang.String;
import java.util.ArrayList;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.FileOutputStream;
import java.io.IOException;

public class Ebnf/*@bgen(jjtree)*/implements EbnfTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTEbnfState jjtree = new JJTEbnfState();

/*@egen*/

	public static void main(String args[]) throws ParseException {

		// Iniciando parser
		Ebnf parser;
		Writer writer = null;

		// Ler de do STD
		if(args.length == 0){
		System.out.println ("\nParser: Reading input ...");
		parser = new Ebnf(System.in);
		}
		// Ler de um ficheiro
		else if(args.length == 1){
			System.out.println ("\nParser: Reading the file " + args[0] + " ..." );
			try {
				parser = new Ebnf(new java.io.FileInputStream(args[0]));
			}
			catch(java.io.FileNotFoundException e) {
				System.out.println ("\nParser: The file " + args[0] + " was not found.");
				return;
			}
		}
		else {
			System.out.println ("Parser:  You must use one of the following:");
			System.out.println ("         java Parser < file");
			System.out.println ("Or");
			System.out.println ("         java Parser file");
			return ;
		}
		try {
			String name = ""+args[0];
			name = name.replace(".txt",".jj");
			writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("JavaCC"+name), "utf-8"));
			SimpleNode root = parser.Start();
			root.dump("",writer,parser.getClass().getName());
			SimpleNode.dumpIds();
			SimpleNode.dumpTokens();
			if(!root.verifyIdentifiers())
			{
				System.out.println("\nABORT!");
				System.exit(1);
			}
			System.out.println ("\nParser: The input was readed sucessfully.");

		}
		catch(ParseException e){
			System.out.println ("\nParser: There was an error during the parse.");
			System.out.println (e.getMessage());
		}
		catch(IOException e){
			System.out.println("\nIO Error: Wasn't able to create/write to the file.");
			System.out.println(e.getMessage());
		}
		catch(TokenMgrError e){
			System.out.println ("\nParser: There was an error.");
			System.out.println (e.getMessage());
		}
		finally{
			try {writer.close();} catch (Exception e) {}
		}

	}
	// Guardar possiveis tokens [Identifier, (Terminal,Terminal,Terminal, ...)]
	/*
	HashMap<String, ArrayList<String>> TokenTable = new HashMap<String,ArrayList<String>>();

    void createTokenTable(SimpleNode node) {
         for(int i=0; i< node.jjtGetNumChildren(); i++) {
                 createTokenTable((SimpleNode) node.jjtGetChild(i));
         }
         if(node.id == EbnfTreeConstants.JJTASSIGNMENT) {
         	//find indentifier and add new String for token... FIXME
                   TokenTable.put(node.identifier, new String(node.val));
                   return;
                   }
        return;
  }
  */
}
PARSER_END(Ebnf)

// s\u00c3\u00admbolos que n\u00c3\u00a3o devem ser considerados na an\u00c3\u00a1lise
SKIP :
{
	" " | "\t" | "\r" | "\n"
}
// defini\u00c3\u00a7\u00c3\u00a3o dos tokens (s\u00c3\u00admbolos terminais)
TOKEN :
{
	< LETTER : ["A"-"Z"] | ["a"-"z"] >
	|
	< DIGIT : ["0" - "9"] >
	|
	< COMMA : "," >
	|
	< EQUALS : "=" >
	|
	< OR : "|" >
	|
	< LPAREN : "(" >
	|
	< RPAREN : ")" >
	|
	< LBRACKET : "[" >
	|
	< RBRACKET : "]" >
	|
	< LBRACE : "{" >
	|
	< RBRACE : "}" >
	|
	< SEMICOLON : ";" >
	|
	< Q_MARK : "\"" >
	|
	< S_QUOTE : "\'" >
	|
	< EXCEPTION : "-" >
	|
	< ASTERIX : "*">
	|
	< SYMBOL : <COMMA> | <EQUALS> | <OR> | <LPAREN> | <RPAREN> | <LBRACKET> | <RBRACKET> | <LBRACE> | <RBRACE> | <SEMICOLON> | <Q_MARK> | <S_QUOTE> |
	 <EXCEPTION> | <ASTERIX> | /*" " |*/ "." | ":" | "!" | "+" | "_" | "%" | "@" | "&" | "#" | "$" | "<" | ">" | "/" | "\\" | "^" | "`" | "\u00c2\u00b4" | "~">
	|
	< CARACTER : <LETTER> | <DIGIT> | <SYMBOL> >
	|
	< IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> | " " | "_")* >
	|
	< TERMINAL : <S_QUOTE> <CARACTER> (<CARACTER>)* <S_QUOTE> | <Q_MARK> <CARACTER> (<CARACTER>)* <Q_MARK> >
	|
	< COMMENT : <LPAREN> "*" (~["*"])* "*" ("*" | ~["*","("] (~["*"])* "*")* <RPAREN>>
	|
	< SPECIAL_SEQUENCE : "?" (~["?"])* "?" >
	//< ALL : ~[] > //?
}
	
//defini\u00c3\u00a7\u00c3\u00a3o da produ\u00c3\u00a7\u00c3\u00a3o
//TODO faltam alguma produ\u00c3\u00a7\u00c3\u00b5es para criar a AST ele est\u00c3\u00a1 a ir buscar mal o nomes da .image. Tamb\u00c3\u00a9m corrigir o problema de pensar que "A" | "B" \u00c3\u00a9 um terminal 
/*
void SpecialSequence() : {}
{
	"?" (~["?"])* "?"
}
*/

void Lhs()          : {/*@bgen(jjtree) RuleName */
                       SimpleNode jjtn000 = new SimpleNode(JJTRULENAME);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) RuleName */
        try {
/*@egen*/
	(t=<IDENTIFIER>{jjtn000.value= ""+t.image.trim().replace(" ", "_"); SimpleNode.addIdentifier(""+t.image);})+/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ // + necessario?
}
/*
void Rhs() #void: {Token t;}
{
	//TODO fIXME talvez separar em novas produ\u00c3\u00a7\u00c3\u00b5es
	//	Rhs1() (( <OR> | <COMMA> ) Rhs())? 
	Rhs1()  
	((
		(

			<OR> {jjtThis.value= "|";} 
			| 
			<COMMA> {jjtThis.value= ",";} 
			|
			<EXCEPTION>
		) 
	Rhs()) #Sequence(2) 
	)? 
}*/

void Rhs()          : {/*@bgen(jjtree) Sequence */
                       SimpleNode jjtn000 = new SimpleNode(JJTSEQUENCE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Sequence */
        try {
/*@egen*/
	//TODO fIXME talvez separar em novas produ\u00c3\u00a7\u00c3\u00b5es
	//	Rhs1() (( <OR> | <COMMA> ) Rhs())? 
	Rhs1()  
	(
		(

			<OR> {jjtn000.value= "|";}
			| 
			<COMMA> {jjtn000.value= ",";}
			|
			<EXCEPTION> 
		) 
	Rhs1() 
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
* repetition-symbol
- except-symbol
, concatenate-symbol
| definition-separator-symbol
= defining-symbol
; terminator-symbol
*/

void Rhs1()      : {Token t;}
{/*@bgen(jjtree) Identifier */
        {
          SimpleNode jjtn001 = new SimpleNode(JJTIDENTIFIER);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(t=<IDENTIFIER>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ { jjtn001.value= ""+t.image.trim().replace(" ", "_");})/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/            
	|/*@bgen(jjtree) Terminal */
        {
          SimpleNode jjtn002 = new SimpleNode(JJTTERMINAL);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ 
	(t=<TERMINAL> 
		{
			jjtn002.value= ""+t.image.trim().replace(" ", "_");
			if(!SimpleNode.containsToken(""+t.image))
				if((""+t.image).equals("\'"))
					SimpleNode.addToken("\"\\"+t.image+"\"");
				else
					SimpleNode.addToken(""+t.image);
		})+/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/           // + necessario?
	|/*@bgen(jjtree) SpecialSeq */
        {
          SimpleNode jjtn003 = new SimpleNode(JJTSPECIALSEQ);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/ 
	(t=<SPECIAL_SEQUENCE>/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn003, true);
                                jjtc003 = false;
                              }
/*@egen*/ { jjtn003.value= ""+t.image;})/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/            
	|
	Precedence()
}

void Precedence()      : {}  //mudamos precedence para void que nao e preciso
{/*@bgen(jjtree) Grouping */
        {
          SimpleNode jjtn001 = new SimpleNode(JJTGROUPING);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<LPAREN> Rhs() <RPAREN>)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/          
	|/*@bgen(jjtree) Option */
          {
            SimpleNode jjtn002 = new SimpleNode(JJTOPTION);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ (<LBRACKET> Rhs() <RBRACKET>)/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
            }
          }
/*@egen*/        
	|/*@bgen(jjtree) Repetition */
          {
            SimpleNode jjtn003 = new SimpleNode(JJTREPETITION);
            boolean jjtc003 = true;
            jjtree.openNodeScope(jjtn003);
          }
          try {
/*@egen*/ (<LBRACE> Rhs() <RBRACE>)/*@bgen(jjtree)*/
          } catch (Throwable jjte003) {
            if (jjtc003) {
              jjtree.clearNodeScope(jjtn003);
              jjtc003 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte003 instanceof RuntimeException) {
              throw (RuntimeException)jjte003;
            }
            if (jjte003 instanceof ParseException) {
              throw (ParseException)jjte003;
            }
            throw (Error)jjte003;
          } finally {
            if (jjtc003) {
              jjtree.closeNodeScope(jjtn003, true);
            }
          }
/*@egen*/            
}
void Rule()      : {/*@bgen(jjtree) Rule */
                    SimpleNode jjtn000 = new SimpleNode(JJTRULE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1;}
{/*@bgen(jjtree) Rule */
        try {
/*@egen*/
	/*t1=Lhs() 
	t2= <EQUALS> {System.out.println("Token : {<EQUALS : '='>}");}
	Rhs() 
	<SEMICOLON>
	*/
	Lhs() t1=<EQUALS> Rhs() <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode Start()       : {/*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*//*Token t1, t2, t3;*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	(Rule() | <COMMENT> )+/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}